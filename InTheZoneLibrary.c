#pragma config(Sensor, in1,    leftClawPoten,  sensorPotentiometer)
#pragma config(Sensor, in2,    liftPoten,      sensorPotentiometer)
#pragma config(Sensor, in3,    rightClawPoten, sensorPotentiometer)
#pragma config(Sensor, in4,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftQuad,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  centerPiston,   sensorDigitalOut)
#pragma config(Sensor, dgtl8,  redLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  yellowLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, greenLED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, leftPiston,     sensorDigitalOut)
#pragma config(Sensor, dgtl12, rightPiston,    sensorDigitalOut)
#pragma config(Motor,  port2,           topLift,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveLeftFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveLeftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           driveRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           driveRightBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           baseLiftLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           baseLiftRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           claw2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma systemFile

////GLOBAL VARIABLES////
//Poten Values For Lift -- Values increase as lift moves backwards
enum PotenValues {BACK = 1000, MATCHLOAD = 1300, SCORE = 4095, BACK_CLAW = 3700, MATCHLOAD_CLAW = 750};
float BACK_KP = 1.7;
float MATCHLOAD_KP = 2;
float SCORE_KP = 1;

//for correctStraight task / driveStraight method
float rightPowerAdjustment = 0;
float leftPowerAdjustment = 0;
float theta = 0;

//for setLiftPos task / setLiftPos method
int desired;
int powAfter;
float kp;
bool reachedMobileGoal = false;

//for setClawUntilPos task / setClawUntilPos
int desiredClaw;
int clawPower;
bool userControlClaw = true;

/////BASIC MOTOR METHODS/////
void setLeftMotors(int power)
{
	motor[driveLeftFront] = power;
	motor[driveLeftBack] = power;
}

void setRightMotors(int power)
{
	motor[driveRightFront] = power;
	motor[driveRightBack] = power;
}
void setAllDriveMotors(int power)
{
	setLeftMotors(power);
	setRightMotors(power);
}

void setTopLiftPower(int power)
{
	motor[topLift] = power;
	//motor[topLiftRight] = power;
}

void setBaseLiftPower(int power)
{
	motor[baseLiftLeft] = power;
	motor[baseLiftRight] = power;
}

void setForkliftPower(int power)
{
	SensorValue[rightPiston] = power;
	SensorValue[leftPiston]  = power;
}

void setClawPower(int power)
{
	motor[claw] = power;
	motor[claw2] = power;

}

/////////TASKS/////////
task correctStraight()
{
	rightPowerAdjustment = 0;
	leftPowerAdjustment = 0;
	int err = theta - SensorValue[gyro];
	int oldErr = err;
	int power;
	int deriv;
	int totalErr = err;
	int integral = totalErr;
	while(1)
	{
		err = theta - SensorValue[gyro];
		deriv = (err-oldErr)*0.5; //if error is increasing, apply more power (compensate for less momentum). else, apply more power
		integral = totalErr * 0.03;
		power = err*0.5 + deriv + integral;
		rightPowerAdjustment = power;
		leftPowerAdjustment = -power;
		oldErr = err;
		totalErr += err;
		//writeDebugStreamLine("Err: %d, Deriv: %d, TotalErr: %d, Integral: %d, Power: %d", err,deriv,totalErr,integral,power);
		wait1Msec(50);
	}
}

task setLiftPosTask() //reachedMobileGoal is only used in auton to stop and hold lift in place if robot reaches goal unexpectedly early
{
	bool ignore = false;
	if((desired == BACK && SensorValue[liftPoten]<BACK) || reachedMobileGoal) //1000 = BACK value
		ignore = true;
	int err = desired - SensorValue[liftPoten];
	int power = 127;

	while(abs(err)>200 &&  !ignore) //adjust power of motors while error is outide of certain range, then set power to 0
	{
		err = desired - SensorValue[liftPoten];
		power = (int) (err*127/4095*kp);
		setTopLiftPower(power);
		//writeDebugStreamLine("Poten: %d, Power: %d, Error: %d", SensorValue[liftPoten], power,err);
	}
	setTopLiftPower(powAfter);
	if(reachedMobileGoal)
		setTopLiftPower(0);
}

task setClawUntilPosTask()
{
	userControlClaw = false;
	setClawPower(clawPower);
	while(SensorValue[liftPoten]>desiredClaw){} //wait until lift goes past a certain point moving from score to back
	setClawPower(-clawPower);
	wait1Msec(10);
	setClawPower(0);
	userControlClaw = true;
}

///////COMPLEX METHODS: a+bi///////
void driveStraight(int dest, int basePower, float rightMultiplier = 0.58) //uses correctStraight task (with gyro) to dive straight
{
	theta = SensorValue[gyro];
	SensorValue[leftQuad] = 0;
	SensorValue[rightQuad] = 0;
	int err = dest;
	int power = 127;
	startTask(correctStraight);
			writeDebugStreamLine("err: %d, power: %d sdfdgdsgfgfsggffs",err,power);
	while(fabs(err)>20 && fabs(dest - (-1*SensorValue[rightQuad]))>20)
	{
		err = dest - SensorValue[leftQuad];
		power = basePower*sgn(err);
		setRightMotors((int)(power*rightMultiplier + rightPowerAdjustment));
		setLeftMotors((int) (power+leftPowerAdjustment));
		//writeDebugStreamLine("RightAdjustment: %d, LeftAdjustment: %d", rightPowerAdjustment, leftPowerAdjustment);
		//writeDebugStreamLine("err: %d, power: %d, rpower: %d",err,power,(int)(power*rightMultiplier + rightPowerAdjustment));
	}
	stopTask(correctStraight);
	setAllDriveMotors(0);
}

void turnToPos(int pos)
{
	clearTimer(T4);
	int err = pos - SensorValue[gyro];
	int power;
	while(fabs(err) > 80 && time1(T4)<2500)
	{
		err = pos - SensorValue[gyro];
		power = 127*err*0.004+10;
		setRightMotors(power);
		setLeftMotors(-power);
		wait1Msec(50);
	}
}

void setLiftPos(int aDesired, float aKp, int aPowAfter = 0)
{
	reachedMobileGoal = false;
	desired = aDesired;
	kp = aKp;
	powAfter = aPowAfter;
	startTask(setLiftPosTask);
}

void setClawUntilPos(int aDesiredClaw, int aClawPower)
{
	desiredClaw = aDesiredClaw;
	clawPower = aClawPower;
	startTask(setClawUntilPosTask);
}
