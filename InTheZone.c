#pragma config(Sensor, in4,    gyro,           sensorGyro)
#pragma config(Sensor, in7,    topLiftPoten,   sensorPotentiometer)
#pragma config(Sensor, in8,    baseLiftPoten,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  forkliftButton, sensorDigitalIn)
#pragma config(Sensor, dgtl6,  greenLED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  sideToggle,     sensorDigitalIn)
#pragma config(Sensor, dgtl8,  minorZoneToggle, sensorDigitalIn)
#pragma config(Sensor, dgtl9,  majorZoneToggle, sensorDigitalIn)
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           topLift,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           driveLeftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           driveRightBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           driveRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mobileLiftLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mobileLiftRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           baseLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw2,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//NOTE: dgt3 and/or dgt4 do not work

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
#include "\InTheZoneLibrary.c"

//for auton task
string aMajorSide;
int aMinorSide;
int aZone;

void pre_auton()
{
	writeDebugStreamLine("begin gyro init");
	SensorType[in4] = sensorNone;
	wait1Msec(1000);
	SensorType[in4] = sensorGyro;
	wait1Msec(2000);
	SensorScale[in4] = 133;
	writeDebugStreamLine("finished gyro init %d", SensorScale[in4]);

	aMajorSide = "blue";

	if(SensorValue[sideToggle] == 1) //if empty (1), then side is left (1), else side is right (-1)
		aMinorSide = 1;
	else
		aMinorSide = -1;

	if(SensorValue[majorZoneToggle] == 0) //if jumper is in (0), zone is 20
		aZone = 20;
	else if(SensorValue[minorZoneToggle] == 1) //if empty (and majorZone is empty), zone is 10, else 5
		aZone = 10;
	else
		aZone = 5;
	//white line -- -1315

		writeDebugStreamLine("Zone in preAuton: %d",aZone);

	SensorValue[greenLED] = 1;

}

void runBasicCompAutonFake(int minorSide, int zone)
{
	//driveStraight(1375,127);
	turnToPos(-900);
	//driveStraight(-800,127);
}

void runBasicCompAuton(int minorSide, int zone)
{
	//minorSide: 1 = left, -1 = right, majorSide parameter not used yet
	clearTimer(T1);
	reachedMobileGoal = false; //will act as hard stop for lifting cone â?? when reachedMobileGoal is true, the lift will immediately drop

	//Go to mobile goal â Drop mobile base lift, lift cone, and drive straight
	setBaseLiftPos(550, 10, -15); //ADD BACK IN
	setForkliftPos(FORKLIFT_DOWN);
	driveStraight(1375,127); //drive to mobile goal

	//pick up goal
	reachedMobileGoal = true; //force cone lift to drop
	setForkliftPos(FORKLIFT_UP);
	//while(SensorValue[forkliftButton] == 1){wait1Msec(20);}
	//setForkliftPower(FORKLIFT_UP * 80);
	wait1Msec(1800);
	setForkliftPower(0);



	if(zone==20)
	{
		turnToPos(140*minorSide);
		setBaseLiftPos(800, 10);
		driveStraight(-1600,127);
	}
	else if(zone == 10)
	{
		//drive back
		turnToPos(0);
		setBaseLiftPos(800, 10); //ADD BACK
		driveStraight(-1200,127); //drive back -1000
	}
	else
	{
		turnToPos(0);
		//setBaseLiftPos(3300, 10); ADD BACK
		driveStraight(-750,127); //drive back -1000
	}
	setClawPower(127);
	wait1Msec(500);
	setBaseLiftPos(500, 10); //ADD BACK

	//Score goal
	if(zone == 5)
	{
		//just turn around and drive straight
		turnToPos(-1800*minorSide);
		setClawPower(0);
		setLeftMotors(127);
		setRightMotors(0);
		while(SensorValue[gyro] < -2145 * minorSide) {}
		setAllDriveMotors(0);
	}
	else if(zone == 10)
	{
		turnToPos(-1800*minorSide);
		setClawPower(0);
		//driveStraight(400,127);
		if(minorSide == 1){
			setLeftMotors(127);
			setRightMotors(0);
		}
		else
		{
			setLeftMotors(0);
			setRightMotors(127);
		}
		while(fabs(SensorValue[gyro]) < 2200) {}
		setAllDriveMotors(0);
	}
	else if(zone == 20)
	{
		////turn roughly parallel to white line, drive forward a bit, turn fully to face 10 pt zone, then drive straight
		//turnToPos(-1320*minorSide);
		//setClawPower(0);
		//driveStraight(300,127);

		turnToPos(1337*minorSide);
		driveStraight(300,127);
	}
	setForkliftPos(FORKLIFT_DOWN);
	driveStraight(350,127);
	//setClawPower(0);
	driveStraight(-500,127,1);
	writeDebugStreamLine("Time: %d", time1(T1));
}

task runEndAuton()
{
	setForkliftPos(FORKLIFT_DOWN);
	wait1Msec(1100);
	//setClawPower(0);
	driveStraight(-500,127,1);
	setTopLiftPower(0);
	writeDebugStreamLine("Time: %d", time1(T1));
}

void runProgSkills()
{
	//run auton to score in 20Z
	string blank = "";
	//runBasicCompAuton(blank,1,20);
	//reset to left?
	//run low power forward?
	//turn w/ gyro to back into left wall
	//back into wall
	//drive to near left corner and score in 10Z left
	//drive to correct spot to align with goal
	//turn w/ gyro
	//drive forward and pick up goal
	//turn 180 to face scoring spot
	//drive forward
	//score 10Z
	//drive to near right corner and score in 10Z right
	//turn
	//drive forward until aligned
	//turn
	//drive forward and pick up goal
	//turn 180 to face scoring spot
	//drive forward
	//score 10Z
	//drive to far right corner and score in 10Z middle
	//turn 180
	//drive forward and pick up goal
	//turn 180
	//drive forward until 5Z
	//turn
	//drive
	//turn to center
	//score goal in 10Z
	//drive to far left corner and score in far 20Z
	//turn to left
	//drive until aligned
	//turn until aligned
	//drive forward and pick up goal
	//drive forward
	//turn
	//drive
	//turn to 20Z
	//score in 20Z
}

task autonomous()
{
	//majorSide = "blue";
	//minorSide = -1; //1 = left, -1 = right
	//zone = 5; //choose 5, 10, or 20
	//clearTimer(T3);
writeDebugStreamLine("the zone %d",aZone);
writeDebugStreamLine("the side %d",aMinorSide);
	runBasicCompAuton(aMinorSide,aZone);
	//while(time1(T3)<12500){wait1Msec(20);}
	//stopTask(runBasicCompAuton);
	//startTask(runEndAuton);
	//runProgSkills(side);
}

task usercontrol()
{
	stopTask(runEndAuton);
	bool coneUpPressed = false;
	bool coneDownPressed = false;
	bool coneZeroPressed = false;
	bool centerPushed = false; //Center piston pushed or naw
	bool autoStackPressed = false;

	while(true)
	{

		if(vexRT[Btn7L]==1)
		{
			driveStraight(600);
		//turnToPos(500);
	//runBasicCompAuton(1,20);
			//setForkliftPos(FORKLIFT_UP);
			//writeDebugStreamLine("Running basic comp auton");
		}
		//if(vexRT[Btn7R]==1)
		//{
		//	string side = "blue";
		//	//runProgSkills();
		//	setForkliftPos(FORKLIFT_DOWN);


		//Buttons and Joysticks
		int  rightJoy = vexRT[Ch2];
		int  leftJoy = vexRT[Ch3];
		word rightTriggerUp = vexRT[Btn6U]; //for score top lift
		word rightTriggerDown = vexRT[Btn6D]; //for back top lift
		word leftTriggerUp = vexRT[Btn5U]; //for pincer close
		word leftTriggerDown = vexRT[Btn5D]; //for pincer open
		word btnEightUp = vexRT[Btn8U]; //for up base lift
		word btnEightDown = vexRT[Btn8D]; //for down base lift
		word btnSevenUp = vexRT[Btn7U]; //forklift up
		word btnSevenDown = vexRT[Btn7D]; //forklift down
		word btnEightLeft = vexRT[Btn8L]; //auto score
		word btnEightRight = vexRT[Btn8R]; //auto back
		word btnSevenLeft = vexRT[Btn7L]; //auton testing
		word btnSevenRight = vexRT[Btn7R]; //move to matchloads
		word secondBtnSevenUp = vexRT[Btn7UXmtr2]; //+1 to cone count
		word secondBtnSevenDown = vexRT[Btn7DXmtr2]; //-1 to cone count
		word secondBtnSevenLeft = vexRT[Btn7LXmtr2]; //zero cone count

		//Drive Motors
		if(fabs(rightJoy) >= 15)
			setRightMotors(rightJoy);
		else
			setRightMotors(0);

		if(fabs(leftJoy) >= 15)
			setLeftMotors(leftJoy);
		else
			setLeftMotors(0);


		//TOP LIFT
		if(rightTriggerUp == 1)
		{
			setTopLiftPower(127);
			//setTopLiftPos(SCORE_TOP,SCORE_KP_TOP);
		}
		else if(rightTriggerDown == 1)
		{
			setTopLiftPower(-80);
			//setTopLiftPos(BACK_TOP,BACK_KP_TOP);
		}

		else
		{
			setTopLiftPower(0);
		}


		//BASE LIFT
		if(btnEightUp == 1)
		{
			if(userControlBase)
				setBaseLiftPower(-127);
			else
				userControlBase = true;
		}
		else if(btnEightDown == 1)
		{
			if(userControlBase)
				setBaseLiftPower(80);
			else
				userControlBase = true;
		}
		else
		{
			if(userControlBase)
				setBaseLiftPower(0);
		}

		//Mobile Goal Base Lifters
		if(btnSevenUp == 1)
		{
			if(SensorValue(forkliftButton) == 1)
				setForkliftPower(127);
			else
				setForkliftPower(0);
		}
		else if(btnSevenDown == 1)
			setForkliftPower(-127);
		else
			setForkliftPower(0);


		//claw
		if(leftTriggerDown == 1)
		{
			if(userControlClaw)
				setClawPower(127); //open claw
			else
				userControlClaw = true;
		}
		else if(leftTriggerUp == 1)
		{
			if(userControlClaw)
				setClawPower(-127); //close claw
			else
				userControlClaw = true;
		}
		else
		{
			if(userControlClaw)
				setClawPower(0);
		}

		//AUTO METHODS
    if(btnEightLeft == 1){autoBack();}
    else if(btnEightRight == 1 && !autoStackPressed) //if button is now pressed, update cones and update bool to reflect button pressed
    {
        autoStackPressed = true;
        autoStack();
        writeDebugStreamLine("Cones Stacked: %d", conesStacked);
    }
    else if(btnEightRight == 0 && autoStackPressed) //if button is no longer pressed, update bool to reflect lack of press
    {
        autoStackPressed = false;
    }

		//if(btnSevenRight == 1)
		//{
		//	setBaseLiftPos(MATCHLOAD_BASE,MATCHLOAD_KP_BASE);
		//	setTopLiftPos(MATCHLOAD_TOP,MATCHLOAD_KP_TOP);
		//}

		if(btnEightLeft == 1){autoBack();}

		/*
		else if(btnEightRight == 1 && !autoStackPressed) //if button is now pressed, update cones and update bool to reflect button pressed
		{
			autoStackPressed = true;
			autoStack();
			writeDebugStreamLine("Cones Stacked: %d", conesStacked);
		}
		else if(btnEightRight == 0 && autoStackPressed) //if button is no longer pressed, update bool to reflect lack of press
		{
			autoStackPressed = false;
		}
		*/

		//cone count
		if(secondBtnSevenUp == 1 && !coneUpPressed) //if button is now pressed, update cones and update bool to reflect button pressed
		{
			conesStacked++;
			coneUpPressed = true;
		}
		else if(secondBtnSevenUp == 0 && coneUpPressed) //if button is no longer pressed, update bool to reflect lack of press
		{
			coneUpPressed = false;
		}

		if(secondBtnSevenDown == 1 && !coneDownPressed) //if button is now pressed, update cones and update bool to reflect button pressed
		{
			conesStacked--;
			coneDownPressed = true;
		}
		else if(secondBtnSevenDown == 0 && coneDownPressed) //if button is no longer pressed, update bool to reflect lack of press
		{
			coneDownPressed = false;
		}

		if(secondBtnSevenLeft == 1 && !coneZeroPressed) //if button is now pressed, update cones and update bool to reflect button pressed
		{
			conesStacked = 0;
			coneZeroPressed = true;
		}
		else if(secondBtnSevenLeft == 0 && coneZeroPressed) //if button is no longer pressed, update bool to reflect lack of press
		{
			coneZeroPressed = false;
		}
	}
}
